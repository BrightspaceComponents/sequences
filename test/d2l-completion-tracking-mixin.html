<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
		<title>d2l-completion-tracking-mixin test</title>
		<script src="../../webcomponentsjs/webcomponents-loader.js"></script>
		<script src="../../web-component-tester/browser.js"></script>
		<script src="../node_modules/polymer-siren-test-helpers/dist/index.js"></script>
        <script src="../node_modules/chai-dom/chai-dom.js"></script>
        <link rel="import" href="../../polymer/polymer-element.html">
		<link rel="import" href="../mixins/d2l-completion-tracking-mixin.html">
	</head>
	<body>
        <script>
            class CompletionTrackingTest extends D2L.Polymer.Mixins.CompletionTrackingMixin(Polymer.Element) {
            	static get is() {
            		return 'completion-tracking-test';
            	}
            }
            customElements.define(CompletionTrackingTest.is, CompletionTrackingTest);
        </script>
		<test-fixture id="MixinFixture">
			<template>
				<completion-tracking-test></completion-tracking-test>
			</template>
        </test-fixture>
		<script>
			/* global SirenFixture */
			describe('d2l-completion-tracking-mixin', () => {
				it('_isImpersonating must return true for an impersonation token', async() => {
					const element = await SirenFixture.load('data/activity-file-html.json', fixture('MixinFixture'));
					const impersonationToken = createFakeToken({ sub: 175, actualsub: 169 });
					const isImpersonating = element._isImpersonating(impersonationToken);
					expect(isImpersonating).to.be.true;
				});

				it('_isImpersonating must return false for an normal token', async() => {
					const element = await SirenFixture.load('data/activity-file-html.json', fixture('MixinFixture'));
					const studentToken = createFakeToken({ sub: 175 });
					const isImpersonating = element._isImpersonating(studentToken);
					expect(isImpersonating).to.be.false;
				});

				it('Updating the entity must call _finishCompletion', async() => {
					const element = await SirenFixture.load('data/activity-file-html.json', fixture('MixinFixture'));
					const finishCompletion = sinon.spy(element, '_finishCompletion');

					element.entity = JSON.parse(JSON.stringify(element.entity));

					expect(finishCompletion).to.have.been.called;
				});

				it('Updating the entity must call _startCompletion', async() => {
					const element = await SirenFixture.load('data/activity-file-html.json', fixture('MixinFixture'));
					const startCompletion = sinon.spy(element, '_startCompletion');

					element.entity = JSON.parse(JSON.stringify(element.entity));

					expect(startCompletion).to.have.been.called;
				});

				it('Updating the entity must not perform completion tracking during impersonation', async() => {
					const element = await SirenFixture.load('data/activity-file-html.json', fixture('MixinFixture'));
					element.token = createFakeToken({ sub: 175, actualsub: 169 });

					const finishCompletion = sinon.spy(element, '_finishCompletion');
					const startCompletion = sinon.spy(element, '_startCompletion');

					element.entity = JSON.parse(JSON.stringify(element.entity));

					expect(finishCompletion).not.to.have.been.called;
					expect(startCompletion).not.to.have.been.called;
				});

				function createFakeToken(jwt) {
					const b64 = btoa(JSON.stringify(jwt));
					const payload = b64
						.replace(/\+/g, '-')
						.replace(/\//g, '_');
					return '.' + payload;
				}
			});
		</script>
	</body>
</html>
